// src/utilisateurs/utilisateurs.service.ts
import {
  Injectable,
  NotFoundException,
  ConflictException,
  InternalServerErrorException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreateUtilisateurDto } from './dto/create-utilisateur.dto'; // Assurez-vous que ce DTO existe pour la mÃ©thode create
import { UpdateUtilisateurDto } from './dto/update-utilisateur.dto'; // Assurez-vous que ce DTO existe pour la mÃ©thode update
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { Role } from '@prisma/client';
import * as bcrypt from 'bcrypt'; // Importez bcrypt pour le hachage du mot de passe

@Injectable()
export class UtilisateursService {
  constructor(private prisma: PrismaService) {}

  /**
   * CrÃ©e un nouvel utilisateur. Cette mÃ©thode est principalement pour les ADMINs
   * pour crÃ©er des utilisateurs directement, sans passer par le processus d'inscription complet
   * qui gÃ¨re les profils. Pour l'inscription avec profils, utilisez auth.register.
   * @param createUtilisateurDto Les donnÃ©es pour crÃ©er l'utilisateur.
   * @returns L'utilisateur crÃ©Ã©.
   */
  async create(createUtilisateurDto: CreateUtilisateurDto) {
  const { email, motDePasse, ...rest } = createUtilisateurDto;
  try {
    const existingUser = await this.prisma.utilisateur.findUnique({
      where: { email },
    });
    if (existingUser) {
      throw new ConflictException(`L'utilisateur avec l'email "${email}" existe dÃ©jÃ .`);
    }

    // ğŸ”‘ Hash du mot de passe
    const hashedPassword = await bcrypt.hash(motDePasse, 10);

    return await this.prisma.utilisateur.create({
      data: {
        ...rest,
        email,
        motDePasse: hashedPassword,
      },
    });
  } catch (error) {
    if (error instanceof ConflictException) {
      throw error;
    }
    if (error instanceof PrismaClientKnownRequestError && error.code === 'P2002') {
      throw new ConflictException(`L'email "${email}" est dÃ©jÃ  utilisÃ©.`);
    }
    console.error('Erreur lors de la crÃ©ation de l\'utilisateur:', error);
    throw new InternalServerErrorException(
      'Erreur interne du serveur lors de la crÃ©ation de l\'utilisateur.'
    );
  }
}

  /**
   * RÃ©cupÃ¨re tous les utilisateurs avec leurs profils (enseignant, Ã©tudiant) et relations imbriquÃ©es.
   * @returns Une liste de tous les utilisateurs.
   */
  async findAll() {
    try {
      return await this.prisma.utilisateur.findMany({
        include: {
          enseignant: {
            include: {
              matieres: {
                include: {
                  matiere: {
                    include: {
                      niveau: true // Inclure le niveau de la matiÃ¨re
                    }
                  }
                }
              }
            }
          },
          etudiant: {
            include: {
              niveau: {
                include: {
                  departement: true // Inclure le dÃ©partement du niveau de l'Ã©tudiant
                }
              }
            }
          },
        },
        orderBy: { nom: 'asc' }, // Tri par nom d'utilisateur
      });
    } catch (error) {
      console.error('Erreur lors de la rÃ©cupÃ©ration des utilisateurs:', error);
      throw new InternalServerErrorException('Erreur interne du serveur lors de la rÃ©cupÃ©ration des utilisateurs.');
    }
  }

  /**
   * RÃ©cupÃ¨re un utilisateur spÃ©cifique par son ID, avec ses profils et relations.
   * @param id L'ID de l'utilisateur.
   * @returns L'utilisateur trouvÃ©.
   */
  async findOne(id: string) {
    try {
      const utilisateur = await this.prisma.utilisateur.findUnique({
        where: { id },
        include: {
          enseignant: {
            include: {
              matieres: {
                include: {
                  matiere: {
                    include: {
                      niveau: true
                    }
                  }
                }
              }
            }
          },
          etudiant: {
            include: {
              niveau: {
                include: {
                  departement: true
                }
              }
            }
          },
        },
      });
      if (!utilisateur) {
        throw new NotFoundException(`Utilisateur avec l'ID "${id}" introuvable.`);
      }
      return utilisateur;
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      if (error instanceof PrismaClientKnownRequestError && error.code === 'P2025') {
        throw new NotFoundException(`Utilisateur avec l'ID "${id}" introuvable.`);
      }
      console.error('Erreur lors de la rÃ©cupÃ©ration de l\'utilisateur:', error);
      throw new InternalServerErrorException(`Erreur interne du serveur lors de la rÃ©cupÃ©ration de l'utilisateur avec l'ID "${id}".`);
    }
  }

  /**
   * Met Ã  jour un utilisateur existant et son profil associÃ©.
   * @param id L'ID de l'utilisateur Ã  mettre Ã  jour.
   * @param updateUtilisateurDto Les donnÃ©es de mise Ã  jour.
   * @returns L'utilisateur mis Ã  jour.
   */
  async update(id: string, updateUtilisateurDto: UpdateUtilisateurDto) {
    const { nom, email, motDePasse, role, etudiantProfile, enseignantProfile } = updateUtilisateurDto;

    try {
      const existingUser = await this.prisma.utilisateur.findUnique({ where: { id } });
      if (!existingUser) {
        throw new NotFoundException(`Utilisateur avec l'ID "${id}" introuvable.`);
      }

      // VÃ©rifier si l'email est modifiÃ© et s'il est dÃ©jÃ  utilisÃ© par un autre utilisateur
      if (email && email !== existingUser.email) {
        const emailConflict = await this.prisma.utilisateur.findUnique({ where: { email } });
        if (emailConflict && emailConflict.id !== id) {
          throw new ConflictException(`L'email "${email}" est dÃ©jÃ  utilisÃ© par un autre utilisateur.`);
        }
      }

      // Hasher le nouveau mot de passe si fourni
      let hashedPassword = existingUser.motDePasse;
      if (motDePasse) {
        hashedPassword = await bcrypt.hash(motDePasse, 10);
      }

      // Mettre Ã  jour l'utilisateur de base
      const updatedUser = await this.prisma.utilisateur.update({
        where: { id },
        data: {
          nom: nom ?? existingUser.nom,
          email: email ?? existingUser.email,
          motDePasse: hashedPassword,
          role: role ?? existingUser.role, // Permettre le changement de rÃ´le si nÃ©cessaire
        },
      });

      // Mettre Ã  jour ou crÃ©er le profil spÃ©cifique si le rÃ´le change ou si des donnÃ©es de profil sont fournies
      if (role === Role.ETUDIANT) {
        if (etudiantProfile) {
          // Si l'utilisateur avait un profil enseignant, le supprimer
          if (existingUser.role === Role.ENSEIGNANT) {
            await this.prisma.enseignant.deleteMany({ where: { utilisateurId: id } });
          }

          // Mettre Ã  jour ou crÃ©er le profil Ã©tudiant
          await this.prisma.etudiant.upsert({
            where: { utilisateurId: id },
            update: {
              matricule: etudiantProfile.matricule,
              niveauId: etudiantProfile.niveauId,
            },
            create: {
              utilisateurId: id,
              matricule: etudiantProfile.matricule,
              niveauId: etudiantProfile.niveauId,
            },
          });
        }
      } else if (role === Role.ENSEIGNANT) {
        if (enseignantProfile) {
          // Si l'utilisateur avait un profil Ã©tudiant, le supprimer
          if (existingUser.role === Role.ETUDIANT) {
            await this.prisma.etudiant.deleteMany({ where: { utilisateurId: id } });
          }

          // Mettre Ã  jour ou crÃ©er le profil enseignant
          const updatedEnseignant = await this.prisma.enseignant.upsert({
            where: { utilisateurId: id },
            update: {
              poste: enseignantProfile.poste,
            },
            create: {
              utilisateurId: id,
              poste: enseignantProfile.poste,
            },
            include: { matieres: true } // Inclure les matiÃ¨res existantes pour comparaison
          });

          // GÃ©rer les matiÃ¨res enseignÃ©es
          if (enseignantProfile.matieresNiveaux) {
            const currentMatiereIds = new Set(updatedEnseignant.matieres.map(m => m.matiereId));
            const newMatiereIds = new Set(enseignantProfile.matieresNiveaux.map(mn => mn.matiereId));

            // MatiÃ¨res Ã  dÃ©connecter (supprimer)
            const matieresToRemove = [...currentMatiereIds].filter(matiereId => !newMatiereIds.has(matiereId));
            if (matieresToRemove.length > 0) {
              await this.prisma.enseignantMatiere.deleteMany({
                where: {
                  enseignantId: updatedEnseignant.id,
                  matiereId: { in: matieresToRemove },
                },
              });
            }

            // MatiÃ¨res Ã  connecter (ajouter)
            const matieresToAdd = enseignantProfile.matieresNiveaux.filter(mn => !currentMatiereIds.has(mn.matiereId));
            if (matieresToAdd.length > 0) {
              // VÃ©rifier l'existence et la cohÃ©rence matiÃ¨re/niveau avant d'ajouter
              for (const { matiereId, niveauId } of matieresToAdd) {
                const matiereNiveauExists = await this.prisma.matiere.findUnique({
                  where: { id: matiereId, niveauId: niveauId },
                });
                if (!matiereNiveauExists) {
                  throw new BadRequestException(
                    `La matiÃ¨re avec l'ID "${matiereId}" n'existe pas pour le niveau "${niveauId}".`,
                  );
                }
              }
              await this.prisma.enseignantMatiere.createMany({
                data: matieresToAdd.map(mn => ({
                  enseignantId: updatedEnseignant.id,
                  matiereId: mn.matiereId,
                })),
                skipDuplicates: true,
              });
            }
          }
        }
      } else if (role === Role.ADMIN) {
        // Si le rÃ´le devient ADMIN, supprimer les profils Ã©tudiant/enseignant existants
        if (existingUser.role === Role.ETUDIANT) {
          await this.prisma.etudiant.deleteMany({ where: { utilisateurId: id } });
        } else if (existingUser.role === Role.ENSEIGNANT) {
          await this.prisma.enseignant.deleteMany({ where: { utilisateurId: id } });
        }
      }

      // Retourner l'utilisateur mis Ã  jour avec ses nouvelles relations
      return await this.findOne(id);
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ConflictException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }
      if (error instanceof PrismaClientKnownRequestError) {
        if (error.code === 'P2002') { // Violation de contrainte unique (ex: email, matricule)
          if (error.meta?.target === 'email') {
            throw new ConflictException(`L'email "${email}" est dÃ©jÃ  utilisÃ©.`);
          }
          if (error.meta?.target === 'matricule') {
            throw new ConflictException(`Le matricule est dÃ©jÃ  utilisÃ©.`);
          }
        }
      }
      console.error('Erreur lors de la mise Ã  jour de l\'utilisateur:', error);
      throw new InternalServerErrorException(
        `Erreur interne du serveur lors de la mise Ã  jour de l'utilisateur avec l'ID "${id}".`,
      );
    }
  }

  /**
   * Supprime un utilisateur par son ID.
   * GÃ¨re la suppression en cascade des profils liÃ©s (enseignant, Ã©tudiant).
   * @param id L'ID de l'utilisateur Ã  supprimer.
   * @returns Un message de succÃ¨s.
   */
  async remove(id: string) {
    try {
      const utilisateur = await this.prisma.utilisateur.findUnique({
        where: { id },
        include: { enseignant: true, etudiant: true },
      });

      if (!utilisateur) {
        throw new NotFoundException(`Utilisateur avec l'ID "${id}" introuvable.`);
      }

      // Supprimer les profils associÃ©s en premier
      if (utilisateur.enseignant) {
        // Supprimer d'abord les liaisons EnseignantMatiere
        await this.prisma.enseignantMatiere.deleteMany({
          where: { enseignantId: utilisateur.enseignant.id },
        });
        // Puis supprimer le profil Enseignant
        await this.prisma.enseignant.delete({ where: { id: utilisateur.enseignant.id } });
      }
      if (utilisateur.etudiant) {
        await this.prisma.etudiant.delete({ where: { id: utilisateur.etudiant.id } });
      }

      // Supprimer l'utilisateur
      await this.prisma.utilisateur.delete({ where: { id } });
      return { message: 'Utilisateur supprimÃ© avec succÃ¨s.' };
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      if (error instanceof PrismaClientKnownRequestError && error.code === 'P2003') {
        throw new ConflictException(`Impossible de supprimer l'utilisateur avec l'ID "${id}" car il est liÃ© Ã  d'autres enregistrements (ex: sÃ©ances, notes).`);
      }
      console.error('Erreur lors de la suppression de l\'utilisateur:', error);
      throw new InternalServerErrorException(`Erreur interne du serveur lors de la suppression de l'utilisateur.`);
    }
  }
}
